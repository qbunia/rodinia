#include "rex_kmp.h" 
char OUT__1__4144__main__121__id__ = 0;
struct __tgt_offload_entry OUT__1__4144__main__121__omp_offload_entry__ __attribute__((section("omp_offloading_entries")))  = {((void *)(&OUT__1__4144__main__121__id__)), "OUT__1__4144__main__121__kernel__", 0, 0, 0};
#include <math.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#define NUM_TEAMS 256
#define NUM_THREADS 1024
#define MAX_ARGS 10
#define REC_LENGTH 49   // size of a record in db
#define REC_WINDOW 10   // number of records to read at a time
#define LATITUDE_POS 28 // location of latitude coordinates in input record
#define OPEN 10000      // initial value of nearest neighbors

struct neighbor 
{
  char entry[49];
  double dist;
}
;
typedef struct latLong {
float lat;
float lng;}LatLong;
/**
 * This program finds the k-nearest neighbors
 * Usage:	./nn <filelist> <num> <target latitude> <target longitude>
 *			filelist: File with the filenames to the records
 *			num: Number of nearest neighbors to find
 *			target lat: Latitude coordinate for distance
 *calculations target long: Longitude coordinate for distance calculations The
 *filelist and data are generated by hurricane_gen.c REC_WINDOW has been
 *arbitrarily assigned; A larger value would allow more work for the threads
 */

int main(int argc,char *argv[])
{
  int status = 0;
  long long time0 = (clock());
  FILE *flist;
  FILE *fp;
  int i = 0;
  int j = 0;
  int k = 0;
  int rec_count = 0;
  int done = 0;
  char sandbox[490];
  char *rec_iter;
  char dbname[64];
  struct neighbor *neighbors = ((void *)0);
  float target_lat;
  float target_long;
  LatLong *locations;
  if (argc < 5) {
    fprintf(stderr,"Invalid set of arguments\n");
    exit(- 1);
  }
  flist = fopen(argv[1],"r");
  if (!flist) {
    printf("error opening flist\n");
    exit(1);
  }
  k = atoi(argv[2]);
  target_lat = (atof(argv[3]));
  target_long = (atof(argv[4]));
  neighbors = (malloc(k * sizeof(struct neighbor )));
  if (neighbors == ((void *)0)) {
    fprintf(stderr,"no room for neighbors\n");
    exit(0);
  }
  for (j = 0; j < k; j++) {
// Initialize list of nearest neighbors to very large dist
    neighbors[j] . dist = 10000;
  }
/**** main processing ****/
  if (fscanf(flist,"%s\n",dbname) != 1) {
    fprintf(stderr,"error reading filelist\n");
    exit(0);
  }
  fp = fopen(dbname,"r");
  if (!fp) {
    printf("error opening flist\n");
    exit(1);
  }
  float *z;
  z = ((float *)(malloc(10 * sizeof(float ))));
  while(!done){
// Read in REC_WINDOW number of records
    rec_count = (fread(sandbox,49,10,fp));
    if (rec_count != 10) {
      if (!ferror(flist)) {
// an eof occured
        fclose(fp);
        if (feof(flist)) 
          done = 1;
         else {
          if (fscanf(flist,"%s\n",dbname) != 1) {
            fprintf(stderr,"error reading filelist\n");
            exit(0);
          }
          fp = fopen(dbname,"r");
          if (!fp) {
            printf("error opening a db\n");
            exit(1);
          }
        }
      }
       else {
        perror("Error");
        exit(0);
      }
    }
    locations = (malloc(sizeof(LatLong ) * rec_count));
    for (i = 0; i < rec_count; i++) {
      rec_iter = sandbox + (i * 49 + 28 - 1);
      locations[i] . lat = (atof(rec_iter));
      locations[i] . lng = (atof((rec_iter + 5)));
    }
{
/* Launch CUDA kernel ... */
      int64_t __device_id = 0;
      int _threads_per_block_ = 1024;
      int _num_blocks_ = 256;
      void *__host_ptr = (void *)(&OUT__1__4144__main__121__id__);
      void *__args_base[] = {(void *)(int64_t)rec_count, (void *)(int64_t)target_lat, (void *)(int64_t)target_long, locations, z};
      void *__args[] = {(void *)(int64_t)rec_count, (void *)(int64_t)target_lat, (void *)(int64_t)target_long, locations + 0, z + 0};
      int64_t __arg_sizes[] = {((int64_t )(sizeof(int ))), ((int64_t )(sizeof(float ))), ((int64_t )(sizeof(float ))), ((int64_t )(sizeof(struct latLong ) * rec_count)), ((int64_t )(sizeof(float ) * 10))};
      int64_t __arg_types[] = {288, 288, 288, 33, 34};
      int32_t __arg_num = 5;
      __tgt_target_teams(__device_id,__host_ptr,__arg_num,__args_base,__args,__arg_sizes,__arg_types,_num_blocks_,_threads_per_block_);
    }
    for (i = 0; i < rec_count; i++) {
      float max_dist = (- 1);
      int max_idx = 0;
// find a neighbor with greatest dist and take his spot if allowed!
      for (j = 0; j < k; j++) {
        if (neighbors[j] . dist > max_dist) {
          max_dist = neighbors[j] . dist;
          max_idx = j;
        }
      }
// compare each record with max value to find the nearest neighbor
      if (z[i] < neighbors[max_idx] . dist) {
        sandbox[(i + 1) * 49 - 1] = '\0';
        strcpy(neighbors[max_idx] . entry,(sandbox + i * 49));
        neighbors[max_idx] . dist = z[i];
      }
    }
    free(locations);
// End while loop
  }
  fprintf(stderr,"The %d nearest neighbors are:\n",k);
  for (j = 0; j < k; j++) {
    if (!(neighbors[j] . dist == 10000)) 
      fprintf(stderr,"%s --> %f\n",neighbors[j] . entry,neighbors[j] . dist);
  }
  fclose(flist);
  long long time1 = (clock());
  printf("total time : %15.12f s\n",(((float )(time1 - time0)) / 1000000));
  return 0;
}
